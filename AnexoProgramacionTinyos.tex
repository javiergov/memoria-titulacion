
\chapter{Programación en TinyOS}
TinyOS es un sistema operativo para sistemas embebidos de código abierto, diseñado especialmente para desarrollar aplicaciones para redes de sensores inalámbricos. Su desarrollo comenzó en la Universidad de Berkeley a fines de los años 90 y actualmente su desarrollo está a cargo de la TinyOS Alliance. TinyOS está diseñado para permitir concurrencia, operación con recursos limitados, soporte para varias plataformas de hardware, y adaptación a la evolución del hardware.\\

El sistema y sus aplicaciones se desarrollan utilizando el lenguaje de programación nesC. Este lenguaje es un dialecto C, que incorpora conceptos como: componentes, interfaces, comandos, tareas y eventos. El ambiente de desarrollo para este sistema está construido para sistemas Unix, sin embargo, puede funcionar sobre sistemas Windows utilizando la herramienta Cygwin. Dentro de las herramientas que provee TinyOS, se pueden encontrar abstracciones para timers, protocolos de comunicación serial, comunicación por radio, protocolos de ruteo, manejo de sensores y persistencia de datos. Actualmente, el sistema soporta las plataformas de hardware: Intelmote2, Iris, Mica, Mica2, Micaz, Shimmer, Telos, TelosB (equivalente a TmoteSky) y Tinynode. 

\section{Instalación y compilación}
El primer paso para desarrollar aplicaciones para el sistema TinyOS es configurar el ambiente de desarrllo. A continuación, se describirán los pasos para instalar el ambiente en un sistema Windows, y posteriormente, los pasos para un sistema Linux.

\subsection{Sistemas Windows}
Para utilizar TinyOS en un ambiente Windows, es necesario instalar la aplicación Cygwin. Esta herramienta habilita un ambiente Linux sobre Windows para ejecutar aplicaciones desarrolladas para el estándar POSIX. Además, es necesario instalar los compiladores para las distintas plataformas que soporta TinyOS, herramientas específicas de TinyOS y el código fuente del sistema. Finalmente, es necesario configurar las variables de entorno para la compilación del sistema. Este tutorial está basado en el manual oficial de instalación publicado en \url{http://docs.tinyos.net/index.php/Installing_TinyOs_2.1} y ha sido probado utilizando Windows XP SP3. 

\subsubsection{Instalación de JDK 1.6}
Realice la instalación del JDK 1.6, descargando la distribución que más le acomode desde \url{java.sun.com}.

\subsubsection{Instalación de Cygwin}
Para la instalación de la aplicación Cygwin debe seguir los siguientes pasos.

\begin{enumerate}
\item Descargar el archivo cygwin-files.zip desde \url{http://cone.informatik.uni-freiburg.de/people/aslam/cygwin-files.zip} y extraer los archivos en una carpeta local (Por ejemplo, C:/cygwin-files/).
\item Ir a la carpeta local y ejecutar el archivo setup.exe.
\item En la pantalla ''Choose installation type'' elija ''Install from a Local Directory''.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=1]{imgs/anexo_tinyos_1.eps} 
\caption{Selección de tipo de instalación para Cygwin.}
\end{figure}
\end{center}

\item En la pantalla ''Select Root Install Directory'' utilice la configuración como se muestra en la figura A.2.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=1]{imgs/anexo_tinyos_2.eps} 
\caption{Selección del directorio raíz para Cygwin.}
\end{figure}
\end{center}

\item En la pantalla "Select Local Package Directoy" seleccione la carpeta donde extrajo los archivos.
\item Complete el resto de la instalación sin modificaciones.
\end{enumerate}

\subsubsection{Instalación de compiladores}
Para realizar la instalación de las herramientas de compilación, debe seguir los siguientes pasos.

\begin{enumerate}
\item Una vez instalado Cygwin, ejecute el acceso directo creado en su escritorio o en el menú de inicio para abrir un terminal de Cygwin.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.80]{imgs/anexo_tinyos_3.eps} 
\caption{Terminal Cygwin.}
\end{figure}
\end{center}

\item En esta pantalla usted podrá ejecutar varios de los comandos de uso habitual del ambiente Unix, en este terminal podrá realizar la instalación de los paquetes RPM que contienen los instaladores para las plataformas soportadas por TinyOS.

\item Descargue los paquetes RPM para el MSP430 desde \url{http://docs.tinyos.net/index.php/Installing_TinyOS_2.1.1#Manual_installation_on_your_host_OS_with_RPMs}. Debe descargar todos los paquetes para Windows que se encuentran en la sección Step 3: Install native compilers, TI MSP430 Tools.

\item A continuación, copie los paquetes descargados a una carpeta dentro de la carpeta ''C:/cygwin/home/NombreDeUsuario'' (donde ''NombreDeUsuario'' es el nombre del usuario con el cuál realizó la instalación de Cygwin).

\item Para instalar cada paquete, debe ejecutar el comando ''rpm -ivh nombre\_del\_paquete.rpm''. En caso de error siga las siguientes instrucciones:

\begin{itemize}
\item Si recibe el mensaje ''warning: user TinyOS User does note exist -using root'', ignórelo. 
\item Si recibe el mensaje ''package nombre is intended for a cygwin\_nt-5.1 ... '', vuelva a intentar la instalación ejecutando ''rpm -ivh --ignoreos nombre.rpm''.
\item Si recibe el mensaje ''error: Failed dependencies...'', vuelva a intentar la instalación ejecutando ''rpm -Uvh --force --nodeps nombre.rpm''.
\item Si recibe un mensaje acerca de conflictos con paquetes instalados previamente, vuelva a intentar la instalación ejecutando ''rpm -Uvh --ignoreos --force nombre.rpm''.
\end{itemize}
\end{enumerate}

\subsubsection{Instalación de herramientas específicas}
Para instalar las herramientas específicas siga los siguientes pasos.

\begin{enumerate}
\item Descargue todos los paquetes para Windows desde  \url{http://docs.tinyos.net/index.php/Installing_TinyOS_2.1.1#Manual_installation_on_your_host_OS_with_RPMs}, de la sección Step 4: Install TinyOS toolchain, TinyOS-specific Tools.

\item Instale el paquete nesc-1.3.0-1.cygwin.i386.rpm utilizando el comando ''rpm -Uvh'', si falla, intente con ''rpm -Uvh --ignoreos''.
\item Instale el paquete tinyos-deputy-1.1-1.cygwin.i386.rpm utilizando el comando ''rpm -i'', si falla, intente con ''rpm -i --ignoreos''.
\item Instale el paquete tinyos-tools-1.3.0-1.cygwin.i386.rpm utilizando el comando ''rpm -ivh''.
\end{enumerate}

\subsubsection{Instalación del código fuente de TinyOS y configuración del entorno}
Descargue el paquete tinyos-2.1.0-2.cygwin.noarch.rpm desde  \url{http://www.tinyos.net/dist-2.1.0/tinyos/windows/tinyos-2.1.0-2.cygwin.noarch.rpm}. A continuación, debe instalarlo ejecutando el comando ''rpm -ivh nombre\_del\_paquete.rpm''. A continuación, cree un archivo llamado tinyos.sh y editelo colocando el siguiente código:

\lstinputlisting[language=bash]{tinyos.sh}

Para finalizar, coloque tinyos.sh en la carpeta ''C:/cygwin/etc/profile.d''.

\subsubsection{Instalación del Driver USB Serial FTDI}
Para que el sistema pueda comunicarse con el Tmote Sky, es necesario instalar el driver FTDI que crea un puerto COM virtual para comunicar el dispositivo mediante el puerto USB. Puede encontrar el driver en el sitio de FTDI \url{http://www.ftdichip.com/Drivers/VCP.htm}.

\subsubsection{Verificar instalación del entorno de desarrollo}
Abra un terminal Cygwin y vaya a la carpeta de la aplicación de ejemplo ''Blink'' , ejecutando ''cd /opt/tinyos-2.x/apps/Blink''. En esta carpeta, compile la aplicación para el dispositivo Tmote Sky ejecutando "make tmote", a continuación se presenta la salida de una compilación correcta.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.60]{imgs/anexo_tinyos_4.eps} 
\caption{Resultado de la compilación exitosa de la aplicación Blink.}
\end{figure}
\end{center}

Para verificar que Cygwin se puede comunicar con el dispositivo, conecte el Tmote y ejecute "motelist". Si el driver USB serial está correctamente instalado debe ver una salida similar a la que se muestra a continuación.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.60]{imgs/anexo_tinyos_5.eps} 
\caption{Resultado exitoso de la ejecución del comando motelist.}
\end{figure}
\end{center}

Ahora, para verificar que puede cargar programas correctamente en el  dispositivo, ejecute make tmote install (en el mismo directorio y con el dispositivo conectado). Si la carga del programa se realizó correctamente debería ver una salida similar a la que se muestra en la figura A.6.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.60]{imgs/anexo_tinyos_6.eps} 
\caption{Resultado exitoso de la carga de una aplicación en el TMoteSky.}
\end{figure}
\end{center}

Luego de realizar este tutorial, su sistema Windows debería quedar configurado para desarrollar aplicaciones para TinyOS 2.1.

\subsection{Sistemas Linux}
Para utilizar TinyOS en un sistema Linux (este tutorial está dirigido a la distribución Ubuntu) se puede realizar una instalación automática de las herramientas, utilizando los repositorios y el sistema de paquetes Debian. 

\subsubsection{Agregar el repositorio de TinyOS para Ubuntu}
Para agregar el repositorio a Ubuntu, es necesario abrir con un editor de textos el archivo etc/apt/sources.list. A continuación, hay que agregar la siguiente línea al final del archivo.

\begin{verbatim}
 deb http://tinyos.stanford.edu/tinyos/dists/ubuntu <distribution> main
\end{verbatim}

Las distribuciones soportadas hasta el momento son: edgy, feisty, gutsy, hardy, jaunty, karmic, lucid. Para finalizar este paso, es necesario actualizar el caché utilizando el comando que se muestra a continuación.

\begin{verbatim}
 sudo apt-get update
\end{verbatim}

A continuación, para instalar tinyos y sus herramientas se debe ejecutar el siguiente código.

\begin{verbatim}
 sudo apt-get install tinyos
\end{verbatim}

Es posible que en el repositorio existan varias versiones de TinyOS, si el comando anterior falla y le sugiere versiones, especifique la versión que desea instalar. Para ver las versiones, puede presionar tab luego de escribir tinyos en el comando anterior. Posteriormente, debe agregar el siguiente código al final del archivo .bashrc.

\begin{verbatim}
if [ -f /opt/tinyos-2.1.0/tinyos.sh ] ; then
. /opt/tinyos-2.1.0/tinyos.sh
fi
\end{verbatim}

Finalmente, debe revisar el archivo /opt/tinyos-2.1.0/tinyos.sh tiene las siguientes líneas.

\lstinputlisting[language=bash]{tinyos_ubuntu.sh}

\subsection{Lenguaje de programación nesC}

NesC es un lenguaje de programación diseñado para sistemas embebidos que funcionan en red. NesC extiende el lenguaje C para incorporar características adicionales de concurrencia y de orientación a componentes, además modifica la estructura de un programa C para adaptarse a las restricciones de memoria de un sistema embebido. La implementación de este lenguaje realiza optimizaciones significativas para sistemas embebidos y ayuda a prevenir problemas de bajo nivel como las ''condiciones de carrera''.

\subsubsection{Componentes e interfaces}
Los principales conceptos que diferencian un programa nesC de uno C son \textbf{los componentes, las interfaces y el "wiring" (cableado)}. Estos conceptos impactan en la organización y espacio de nombres de un programa nesC. En C, los programas se separan en archivos (.c) que son enlazados mediante un espacio de nombres global, generalmente, con la ayuda de un archivo de cabecera (.h). NesC es un "lenguaje orientado a componentes", es decir, un programa nesC es una colección de componentes enlazados (cableados) vía interfaces. 

Un \textbf{componente} es un grupo de elementos relacionados funcionalmente en una unidad, similar a una clase en un lenguaje orientado a objetos. Un componente está organizado en 2 secciones: la primera sección se utiliza para especificar las interfaces que provee y utiliza, y la segunda se utiliza para implementar las funcionalidades del componente.\\

Una \textbf{interfaz} es un medio bidireccional que especifica las funciones que deben ser implementadas por el componente proveedor de la interfaz (comandos) y las funciones que deben ser implementadas por el componente usuario de la interfaz (eventos). Así, un componente que llama los comandos definidos en una interfaz, debe implementar los eventos que define esa interfaz. Un único componente puede implementar varias interfaces y múltiples instancias de la misma interfaz.\\

En nesC, existen dos tipos de componentes: los módulos y las configuraciones. Un módulo provee la implementación de una o más interfaces, mientras que las configuraciones son utilizadas para agrupar varios componentes, conectando las interfaces usadas por un componente a las interfaces provistas por otros componentes. Una aplicación nesC está finalmente descrita por una configuración de alto nivel que enlaza todos los componentes que la conforman.

En la práctica, cuando se escribe un programa nesC, se comienza con la definición de una configuración en un archivo .nc. Por convención, los archivos que describen una configuración son nombrados de la forma ''nombreC'' (por ejemplo AppC.nc). El archivo que implementa la configuración tiene la siguiente estructura.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/Ejemplo0_ModeloComponente_AppC_nc.eps} 
 	\caption{Ejemplo de configuración}
\end{figure}

La palabra reservada ''configuration'' es la que permite realizar la declaración de la configuración, en el ejemplo anterior, ''configuration AppC'' declara la configuración AppC. La palabra reservada ''implementation'' da inicio a la sección de implementación de la configuración. La sección de implementación de una configuración consiste en especificar como están conectados cada uno de los componentes que conforman la configuración. Primero se utiliza la palabra reservada ''components'' para indicar cuales son los componentes que se utilizan para construir la configuración, en el caso del ejemplo, se utilizan los componentes ficticios ''Componente1P'' y ''Componente2P''. Luego de declarar los componentes, se especifican las relaciones entre ellos utilizando los operadores $\rightarrow$ y $\leftarrow$. Estos operadores realizan un cableado directo de la interfaz que utiliza un componente, con la interfaz que provee el componente. La flecha siempre va desde el componente usuario al componente proveedor. En la figura A.7, el Componente1P provee la Interfaz1, mientras que el Componente2P utiliza la Interfaz1. El Componente2P provee la Interfaz2 y utiliza la Interfaz1\\

Las interfaces también deben ser especificadas en un archivo .nc (Por ejemplo, ''Interfaz1.nc). Un ejemplo de la estructura de un archivo que especifica una interfaz se muestra en la figura A.8.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/Ejemplo0ModeloComponenteInterfaz1nc.eps} 
 	\caption{Estructura de un archivo de ejemplo que especifica una interfaz}
\end{figure}

Para especificar una interfaz, se debe utilizar la palabra reservada ''interface'' seguida del nombre de la interfaz. El contexto que limitan las llaves se utiliza para declarar los comandos y eventos que especificará ésta interfaz.\\

El archivo que implementa el módulo Componente1P debe poseer una estructura como la que se muestra en la figura A.9.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/Ejemplo0ModeloComponenteComponente1Pnc.eps} 
 	\caption{Estructura de un archivo de ejemplo que implementa un módulo}
\end{figure}

La palabra reservada ''module'' es la que se utiliza para declarar un componente. En la primera sección, se utiliza la palabra reservada ''uses'' para declarar cuáles son las interfaces que usa el componente. También, se utiliza la palabra reservada ''provides'' para declarar cuáles son las interfaces que provee el componente. La segunda sección consiste en la implementación del módulo, donde se construyen las funcionalidades del componente, utilizando e implementando interfaces.

\subsection{Visualización de componentes}
En este tutorial se utilizará el lenguaje visual propuesto en \cite{TinyOSProgramming} para representar las relaciones entre componentes. En la figura A.10, se muestran las representaciones para los dos tipos de componentes que se utilizan en el lenguaje nesC: los módulos, son representados por cajas de bordes redondeados, dibujadas con una línea continua; las configuraciones, son representadas por cajas de bordes redondeados, dibujadas con una línea punteada. Las interfaces que provee un componente son representadas por un triángulo sólido de color negro. Si el componente provee la interfaz, el triángulo se dibuja dentro de la caja, con la base adyacente a la línea que dibuja la caja del componente. Si el componente utiliza la interfáz,  el triángulo se dibuja fuera de la caja, con la base adyacente a la línea que dibuja la caja del componente. 

\begin{figure}[h!]
	\centering
 	\includegraphics[scale=0.5]{imgs/VisualizacionDeComponentes.eps} 
 	\caption{Representación visual de componentes}
\end{figure}

En la figura A.11 se muestra la relación del ejemplo descrito en la sección anterior utilizando el lenguaje visual. 

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/VisualizacionComponentesEjemplo.eps} 
 	\caption{Representación visual de una configuración}
\end{figure}

Es usual que el nombre de la configuración se coloque en el extremo superior izquierdo de la caja, para dejar espacio a las relaciones de los componentes y configuraciones que la componen. En la figura A.11 se muestra la configuración AppC, que está construida utilizando los componentes ''Componente1'' y ''Componente2''.  En este diagrama, se observa como las interfaces relacionan el Componente1 con el Componente2: El Componente1 provee la Interfaz1 y usa la Interfaz2; mientras que el Componente2 provee la Interfaz2 y usa la Interfaz1. 

\section{Introducción al Modelo de Ejecución de TinyOS}
%tares, comandos, events, async, sync, signal, splitphase.
%Overview
El modelo de ejecución de TinyOS tiene las siguientes características:
\begin{itemize}
\item Considera que todas las operaciones de entrada y salida se realizan en dos pasos (split-phase).
\item No provee hebras, en cambio, el la ejecución del programa es conducida por events (eventos) y tasks  (tareas).
\end{itemize}

En las secciones siguientes se describirán las características de las tareas, comandos y eventos.

\subsection{Tasks}
Una tarea es un mecanismo de computación diferida que permite realizar largos ciclos de ejecución y que será ejecutada hasta el final, sin importar si es interrumpida. Cuando se invoca una tarea, esta no es ejecutada de inmediato, sino que es encolada. Las tareas encoladas son ejecutadas por el Scheduler en el orden en que se encolaron y de a una a la vez. En la figura A.12 se muestra la estructura que tiene la implementación de una tarea.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/EstructuraTask1.eps} 
 	\caption{Estructura del código de una tarea.}
\end{figure}

La palabra reservada ''task'' se utiliza para declarar una tarea. Una tarea es similar a una función, puede acceder a variables, invocar comandos o funciones C, y señalizar eventos. Para invocar una tarea, se utiliza la palabra reservada ''post''. El operador post genera un valor de retorno de tipo error\textunderscore t, si la tarea no está pendiente retorna SUCCESS, si lo está retorna FAIL.\\

Las tareas, al ejecutarse una a una, no se pueden interrumpir ni adelantar entre ellas. Este esquema sincrónico de ejecución permite prescindir de herramientas como candados, semáforos o monitores.  

\subsection{Commands}
Un comando es una pieza de código que es implementada por el proveedor de una interfaz. Los comandos permiten al componente usuario de una interfaz utilizar los servicios que otro componente provee. Por ejemplo, la interfaz Leds, provee comandos para encender leds, apagar leds, alternar el estado de los leds y utilizar los leds para representar un número binario.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/interfaceLeds.eps} 
 	\caption{Especificación de la interfaz Leds}
\end{figure}

En la figura A.13 se muestra la especificación de la interfaz Leds, que se encuentra en el archivo TOS\textunderscore DIR/tos/interfaces/Leds.nc.  El comando led0On() permite encender el led0, mientras que el comando led0Off permite apagarlo. El comando get() permite obtener el estado de los leds mediante una representación binaria de sus estados, mientras que el comando set(uint8\textunderscore t val) permite establecer el estado de los leds mediante una representación binaria.\\

Se puede observar que cada declaración de comando comienza con la palabra reservada ''async''. Los comandos se ejecutan por defecto de manera sincrónica, sin embargo, nesC permite que se ejecuten comandos de manera asincrónica declarándolos como async. No es recomendable utilizar comandos o eventos asincrónicos, a menos que los tiempos sean importantes para la aplicación.\\

Como se mencionó al comienzo de la sección A.2, las operaciones de entrada y salida se realizan en dos fases, por lo que es usual que un comando involucre un callback (respuesta por parte del componente), en forma de un evento.

\subsection{Events}
Los eventos son piezas de código que deben ser implementada por el usuario de una interfaz, para manejar las respuestas a los servicios que provee un componente, que han sido iniciados por la invocación de un comando.

Un ejemplo de operación en split-phase es la lectura de un sensor utilizando la interfaz ''Read''.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/InterfaceRead.eps} 
 	\caption{Interfaz Read}
\end{figure}

Como se muestra en la figura A.14, la interfaz Read especifica el comando read() y el evento readDone(error\textunderscore t result, val\textunderscore t val), donde la llamada a read() inicia una medición y cuando la medición está lista, el componente proveedor señaliza el evento readDone, entregándole el resultado de la operación de medición (result)  y el valor obtenido de la medición (val).\\ 

Los eventos se invocan utilizando la palabra reservada ''signal''. Los eventos también son sincrónicos  por defecto , sin embargo, pueden declararse eventos asincrónicos precediendo la declaración por la palabra reservada async. 

\section{Introducción a la API de TinyOS}
Si bien TinyOS hace un esfuerzo por abstraer las interfaces y componentes del hardware, utilizando varias capaz de abstracción, gran parte de la API continúa siendo específica para cada plataforma de hardware. En esta sección, se describirán los componentes e interfaces utilizados en este trabajo para el desarrollo sobre la plataforma TmoteSky.

%UserButton y Leds
\subsection{Leds y Botón de Usuario}
Los componentes más simples del sistema son los Leds y el Botón de Usuario. Además, estos componentes son muy útiles a la hora de depurar una aplicación, obteniendo cierta realimentación con los Leds y gatillar eventos con el botón.\\

El componente UserButtonC es el que implementa el botón de usuario para el TmoteSky. Este componente, provee las interfaces Get\textless button\_state\_t\textgreater y Notify\textless button\_state\_t\textgreater.  Get permite obtener el estado del botón, mientras que Notify permite habilitar un evento que se gatilla con un cambio de estado del botón.\\

El componente LedsC es el componente que implementa los leds para el TmoteSky. Provee la interfaz Leds, que especifica una serie de comandos que permiten gestionar el estado de los leds individualmente o en conjunto.\\

Para demostrar como se pueden utilizar estos componentes, se implementa una aplicación con las siguientes funcionalidades:

\begin{itemize}
\item La aplicación debe utilizar el componente UserButtonC para monitorear los cambios de estado del botón.
\item Cada vez que se presiona el botón, la aplicación incrementa un contador y muestra una representación binaria del contador, utilizando los Leds.
\end{itemize}

Para esta aplicación se implementarán los archivos: AppC, para el código de la configuración; AppP, para el código del módulo; Makefile para el archivo de construcción de la aplicación.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/LedsBotonAppC.eps} 
 	\caption{Código de la configuración de la aplicación}
\end{figure}

En al figura A.15 se muestra el código de la configuración AppC.  En la sección de implementación, primero se declaran los componentes que se utilizarán: UserButtonC, AppP con el nombre App y LedsC. Luego se realiza el wiring de las interfaces, el componente App utilizará la implementación de la interfaz Notify que provee el componente UserButtonC, además, el componente App utilizará la implementación de la interfaz Leds que provee el componente LedsC.\\

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/LedsBotonAppP.eps} 
 	\caption{Código del módulo de la aplicación}
\end{figure}

El código que se describe en la figura A.16 corresponde al del módulo de la aplicación, escrito en el archivo AppP.nc. El módulo utiliza tres interfaces: Boot, que es cableada automáticamente por el compilador y que se utiliza para implementar el código que se ejecuta cuando inicia el sistema; la interfaz Leds, que se utilizará para manejar el estado de los leds; y la interfaz Notify, que es la interfaz que provee el componente UserButtonC para monitorear los cambios de estado del botón.\\

La sección de implementación comienza con la declaración de la variable contado, que se utiliza para contar cuantas veces el usuario a presionado el botón. A continuación se implementa el evento Boot.booted(), este evento se ejecuta luego de iniciar el sistema, y permite inicializar variables y componentes. En esta aplicación, se utiliza el evento para inicializar el contador en cero y habilitar la señalización del evento Notify.notify(button\_ state\_ t b\_ state) utilizando el comando Notify.enable(). El evento Notify.notify(button\_ state\_ t b\_ state) se gatilla cada vez que hay un cambio de estado del botón, y entrega a través de la variable b\_ state, el nuevo estado. Al utilizar la interface Notify, es obligación implementar el evento Notify.notify(...), de otra forma el compilador generará como salida un error. Siempre que se utiliza una interfaz, se deben implementar todos los eventos que especifica dicha interfaz. En la implementación dele evento Notify.notify(...), se revisa que el estado entregado a través de la variable b \_ state sea igual a BUTTON\_ PRESSED, si es así se incrementa el contador y se llama al comando Leds.set(uint8\_ t val)  para mostrar a través de los led, los tres bits menos significativos del contador.\\

Los componentes, LedsC y UserButton, permiten al programador tener cierto grado de retroalimentación y de interacción en las tareas de desarrollo. En la próxima sección se describirán ejemplos para comunicar el TMoteSky con un computador, lo que permite al desarrollador disponer de herramientas aún más útiles para las tareas de desarrollo.
%Comunicación por serial
\subsection{Comunicación TMoteSky-PC}

\subsubsection{Librería printf}
Una práctica que se utiliza comúnmente para depurar programas C, es utilizar la función ''printf''. Esta función permite imprimir mensajes con valores de variables o en alguna posición determinada del código para verificar rápidamente si el programa está funcionando como el desarrollador lo espera. Para TinyOS se ha implementado una librearía que provee la función printf y que permite imprimir mensajes al puerto serial de TMoteSky. Para visualizar los mensajes es necesario ejecutar una aplicación Java en el PC, que se distribuye con el sistema, y que permite recibir los mensajes por un puerto USB e imprimirlos la consola del sistema.\\

Para utilizar la librería "printf.h" se deben realizar las siguientes modificaciones a un programa nesC.

\begin{enumerate}
\item Agregar al MAKEFILE el directorio ''TOSDIR/lib/printf'' para proveer el enlace a la librería. Opcionalmente, es posible establecer el largo del buffer utilizado para la función, por defecto tiene un tamaño de 250 bytes.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/PrintfMakefile.eps} 
 	\caption{Código del módulo de la aplicación}
\end{figure}

\item Incluir la librería ''printf.h'' en el archivo que implemente el componente que desea utilizarla. Para incluirla, basta utilizar la instrucción del pre procesador de C \# include ''printf.h''.
\end{enumerate}

Con estas modificaciones realizadas se puede utilizar la función printf(''mensaje'') para enviar mensajes por el puerto serial hacia un PC. En el lado del PC, se debe ejecutar el cliente Java para el printf que se distribuye con las herramientas Java de TinyOS. La ejecución del comando difiere dependiendo del sistema en que se está trabajando, ya que sistemas Linux y Windows los puertos seriales y USB son representados con distintos nombres. Por ejemplo en el sistema Linux Ubuntu la instrucción tiene la forma:
\begin{verbatim}
 java net.tinyos.tools.PrintfClient -comm serial@/dev/ttyUSB0:telosb
\end{verbatim}

Mientras que en un sistema windows tiene la forma:
\begin{verbatim}
 java net.tinyos.tools.PrintfClient -comm serial@COM1:telosb
\end{verbatim}

Para obtener el puerto al cuál tiene conectado el dispositivo, puede utilizar el comando ''motelist'', que se instala junto con el sistema. El parámetro ''telosb'' indica el bit rate (tasa de transmisión de bits) que se utilizará para la comunicación.

\subsubsection{Comunicación serial con SerialActiveMessageC}
TinyOS provee para la comunicación por radio el ''Radio Stack'' que provee un tipo de mensajes de largo fijo para comunicaciones single-hop denominado ActiveMessage. Para la comunicación serial TinyOS provee la misma abstracción de mensajes, lo que facilita el reenvío de los mensajes que el TmoteSky recibe por radio hacia el serial, y en sentido inverso.\\

Por el lado del PC, TinyOS prove la clase Java MoteIF, esta clase se encarga de escuchar el puerto serial o un socket, e interpretar los ActiveMessage que recibe por esa fuente y gatillar manejadores de eventos para uno o varios ActiveMessage IDs. 

%Comunicación por radio
\subsection{Comunicación por radio}
	%ActiveMessages
TinyOS provee un set de componentes e interfaces que habilitan una pila de comunicación single-hop denominada ''Radio Stack''. En la cabeza de esta pila, se encuentra la implementación ActiveMessage, que es la capa que se encarga de multiplexar el acceso de los distintos servicios de TinyOS a la radio. Esta capa utiliza el identificador ''AM Type'' para discriminar entre los servicios, similar a un puerto UDP. \\

TinyOS provee la abstracción message\_t, que corresponde a una estructura nesC que almacena punteros para una cabecera, una sección de datos, y una sección posterior a los datos para métadatos. Para acceder, modificar y enviar o recibir por el aire un message\_t, se deben utilizar las interfaces que provee el sistema, en particular, las interfaces de la capa ActiveMessage.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{imgs/EjemploAnexoRadioWiring.eps} 
\caption{Código con el cableado de los componentes necesarios para utilizar la comunicación por radio.}
\end{figure}
\end{center}

En la figura A.18 se muestran los componentes y el cableado de ellos a la aplicación que se debe realizar en el archivo de configuración para utilizar la comunicación por radio. El primer componente es ''ActiveMessageC'' que provee un control split phase para controlar la radio. En este ejemplo se cablea la interfaz split control con el nombre local de RadioControl a un módulo App, donde App es el nombre con el que se denomina al módulo principal en este ejemplo (puede ser el nombre que el programador elija). El siguiente componente utilizado es AMSender, al cuál se le asigna el nombre local EjemploSender. Este componente es instanciado con el comando new (una configuración nesC puede utilizar varias instancias de este componente con distintos nombres) y se le entrega como argumento AM\_EJEMPLO\_MSG que corresponde al AM\_TYPE que utilizará esta instancia de AMSender. AM\_TYPE es un identificador que puede asumir un valor entre 0x0000 y 0xFFFF, y su uso es similar a un puerto UDP: Permite que una aplicación utilice distintos servicios para mensajes asociados a distintos AM\_TYPE. El componente AMSender es el que provee las interfaces para construir un paquete y enviarlo por el aire utilizando la pila de comunicación ActiveMessage. El último componente utilizado es el AMReceiver, que se denomina localmente como EjemploReceiver, y es el que provee la interfaz Receive para recibir mensajes. Al igual que el componente AMSender, este componente es instanciado utilizando la palabra reservada new y con un AM\_TYPE como argumento.

\subsubsection{Definir la estructura de un mensaje} 
Para que los motes intercambien información por la radio, el primer paso es definir la estructura del mensaje que intercambiarán. No es obligación definir una estructura para los mensajes, pero tiene ventajas sobre la utilización de un buffer, ya que cuando el mensaje tiene campos con distintos tipos de datos (uint8, uint16, uint32, etc)  el código necesario para acceder a los miembros de la estructura es más corto que usar índices para acceder al buffer.  

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{imgs/EstructuraMensajeEjemplo.eps} 
\caption{Ejemplo de estructura de mensaje.}
\end{figure}
\end{center}
 
Además, este tipo de estructura de mensajes permitirá utilizar la herramienta MIG. Esta herramienta, permite generar una clase Java que representa el mensaje y provee los métodos necesarios para acceder y modificar todos los campos del mensaje, en una aplicación de escritorio. 

\subsubsection{Enviar mensajes por el aire}
Para enviar un mensaje por el aire, utilizando la radio, usualmente se implementa una función que realiza las operaciones necesarias para entregar un mensaje a la pila de comunicación ActiveMessage, que se encargará de gestionar los recursos necesarios para que ese mensaje salga por el aire. A continuación, se muestra el código sugerido para enviar un mensaje del tipo Ejemplo\_Msg\_t.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{imgs/SendEjemploMsg.eps} 
\caption{Ejemplo de función que envía un mensaje del tipo Ejemplo\_Msg\_t.}
\end{figure}
\end{center}

En la figura A.20 se muestra el código necesario para enviar un mensaje por el aire. La función ''sendEjemploMsg'' se define del tipo ''error\_t'', es decir, la función sólo tiene dos posibles valores de retorno: SUCCESS o FAIL. Como argumentos recibe: destaddr, que es un entero sin signo de 16 bits que representa el TOS\_NODE\_ID del mote destinatario del mensaje; c1, campo de ejemplo 1; c2, campo de ejemplo 2; c3, campo de ejemplo 3. La función comienza con la declaración de la variable ejemploPkt, del tipo message\_t, que representa un mensaje para la pila ActiveMessage. A continuación, se revisa el flag radiobusy (se supone que esta variable existe y se utiliza para indicar si se está ocupando la radio o no): si es falso, indica que la radio está desocupada, entonces la función continúa con las operaciones de envío; si es verdadero, indica que la radio está ocupada,  entonces la función simplemente retorna FAIL. Luego, se define un puntero del tipo Ejemplo\_Msg\_t (siguiendo lo definido en la sección anterior), ejemploMsg, al cuál se le asigna la dirección del ''payload'' (carga) del mensaje message\_t declarado con anterioridad. Así, los datos que se guardan en ejemploMsg quedarán guardados en la carga del mensaje message\_t. A continuación, se asignan los valores a la estructura y posteriormente (dentro de la condición del segundo if) se realiza el envío del mensaje, llamando al comando send de la interfaz EjemploAMSend. Si el llamado retorna un valor distinto de SUCCESS, entonces la función sendEjemploMsg retorna FAIL; si el llamado retorna SUCCESS, entonces la función le asigna TRUE a radiobusy para indicar que la radio ahora estará ocupada enviando el mensaje. Como se explicó anteriormente, cada operación de entrada/salida es manejada por TinyOS en dos partes, y en este caso, solicitar a la pila de comunicación que envíe el mensaje corresponde a la primera parte. La segunda, corresponde a manejar el evento sendDone.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{imgs/EjemploSendDone.eps} 
\caption{Ejemplo de manejo del evento sendDone.}
\end{figure}
\end{center}

El código que se muestra en la figura A.21 es el que se ejecutará una vez que el mensaje ha sido enviado, en este ejemplo simplemente se vuelve a asignar FALSE al flag radiobusy.

\subsubsection{Recibir mensajes por el aire}
Para recibir un mensaje por el aire se utiliza la interfaz AMReceive. Para utilizar este componente, además de cablear el componente como se mostró al comienzo de la sección A.3.3, se debe implementar el manejador para el evento AMReceive.receive.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{imgs/EjemploReceive.eps} 
\caption{Ejemplo de manejo del evento Receive.}
\end{figure}
\end{center}

Como se muestra en la figura A.22, el evento entregará a través de los argumentos un puntero al mensaje ''msg'', un puntero a la carga del mensaje ''payload'' y el largo ''len'' del mensaje. Como se muestra en la figura, asignando ''payload'' a un puntero local del tipo de mensaje (Ejemplo\_Msg\_t) se tendrá acceso a todos los miembros de la estructura de este.

%ACKs
\subsubsection{Utilización de ACKs}
Para utilizar los ACKs se deben realizar los siguientes pasos: Primero cablear la interfaz PacketAcknowledgements del componente ActiveMessageC al módulo que utilizará los ACKs; luego, modificar la función send para que se indique en la cabecera de los mensajes que se requiere el ACK; y finalmente, revisar en el evento sendDone si se ha recibido o no el ACK.

El primer paso corresponde a cablear la interfaz PacketAcknowledgements que provee el componente ActiveMessageC al módulo que la utilizará, esto se realiza modificando el archivo de configuración ingresando una línea como se muestra a continuación.

\begin{verbatim}
MiModulo.PacketAcknowledgements->ActiveMessageC;
\end{verbatim}

Luego, se debe modificar la función send para indicar en la cabecera del mensaje que se requiere un ACK para este.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{imgs/EjemploSendAck.eps} 
\caption{Modificación a la función send para requerir ACK.}
\end{figure}
\end{center}

En la figura A.23 se muestra la función send modificada para requerir ACK para un mensaje. La modificación consiste en agregar una línea para invocar el comando requestAck de la interfaz PacketAcknowledgements. Luego, para verificar la recepción de un ACK se debe modificar el evento sendDone como se muestra a continuación.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{imgs/EjemploSendDoneAck.eps} 
\caption{Modificación al evento sendDone revisar recepción de ACK.}
\end{figure}
\end{center}

En la figura A.24 se muestra la modificación para revisar si el ACK fue recibido. La modificación consiste en invocar el comando wasAcked() de la interfaz PacketAcknowledgements.

%RSSI
\subsubsection{Obtener el RSSI de un mensaje recibido}
Para obtener el RSSI de un mensaje recibido es necesario modificar el archivo con la configuración para agregar el componente necesario. Se debe agregar la siguiente línea a la declaración de componentes.

\begin{verbatim}
components CC2420ActiveMessageC;
\end{verbatim}

A continuación, se debe cablear la interfaz CC2420Packet al módulo.

\begin{verbatim}
MiModulo->CC2420ActiveMessageC.CC2420Packet;
\end{verbatim}

Finalmente, se debe modificar el evento receive como se muestra a continuación.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{imgs/EjemploSendDoneAck.eps} 
\caption{Modificación al evento receive para obtener el RSSI de un mensaje.}
\end{figure}
\end{center}

%SensoresTmoteSky
%\subsubsection{Utilización del sensor de Luz}

%LowPowerListening
\subsubsection{Operación de bajo consumo - Low Power Listening}
Para aplicaciones que requieran extender el tiempo de duración de la carga de las baterías, TinyOS provee la herramienta Low Power Listening. Esta herramienta, reduce el consumo de energía disminuyendo el tiempo de ''idle listening''. Para lograr esto, se implementa un ciclo de trabajo para la radio donde primero se activa la recepción por el tiempo necesario para detectar un ''carrier'' en el canal; si no hay carrier, apaga la radio por un intervalo de tiempo denominado ''Intervalo LPL''; si hay carrier, se mantiene la radio encendida para recibir el mensaje. Por otro lado, para lograr entregar un mensaje, el transmisor extiende el preámbulo del mensaje hasta que la duración temporal alcance el intervalo LPL. En el anexo C se profundiza en la herramienta Low Power Listening.\\

Para utilizar este componente, primero se deben declarar y cablear los siguientes componentes en el archivo de configuración.

\begin{verbatim}
components CC2420ActiveMessageC;
MiModulo.LowPowerListening -> CC2420ActiveMessageC;
\end{verbatim}

Luego, para iniciar el ciclo de trabajo en el receptor, se debe invocar el siguiente comando.
\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{imgs/InvocacionLowPowerListening.eps} 
\caption{Invocación para iniciar el ciclo de trabajo de Low Power Listening.}
\end{figure}
\end{center}

En el transmisor, se debe agregar la siguiente modificación a la función de envío del mensaje.

\begin{center}
\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{imgs/SendLPL.eps} 
\caption{Modificación al código de la función send para utilizar LPL.}
\end{figure}
\end{center}

La modificación que se muestra en la figura A.27 consiste en agregar la línea que invoca al comando ''LowPowerListening.setRxSleepInterval(\&ejemploPkt). Este comando marca el paquete para que la pila de comunicación extienda el preámbulo del envío para que el receptor que utiliza LPL lo pueda recibir correctamente.\\

Finalmente, es necesario modificar el Makefile de la aplicación para que el compilador utiliza la pila de comunicación que implementa LPL para construir el archivo binario. La modificación consiste en agregar el siguiente flag de compilación.
\begin{center}
\begin{verbatim}
CFLAGS += -DLOW_POWER_LISTENING
\end{verbatim}
\end{center}

Con estas modificaciones la aplicación debe habilitar correctamente las operaciones de comunicación de bajo consumo.
