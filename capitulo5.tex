\chapter{Implementación del protocolo con topología de árbol}

\section{Descripción de la implementación}
La implementación del esquema de recolección propuesto en la sección anterior, se realiza programando un ''Componente de recolección'', se divide en dos módulos:  el ''Componente de ruteo'', que es el encargado de formar la red y establecer la ruta hacia el punto de recolección; y la implementación del componente de reenvío, que es el encargado de encolar y reenviar los mensajes.\\

\subsection{Componente de Recolección - CollectionC}
La implementación del componente de recolección, diseñado en capítulo 3, comienza con la programación de una configuración nesC que provee una interfaz similar a la que provee CTP\cite{TEP123}. La configuración se denomina CollectionC, y provee la implementación de las interfaces: \textbf{SplitControl, Send, Receive y Broadcast}. La descripción  de CollectionC se realiza en el archivo CollectionC.nc.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/DiagramaComponenteCollectionC.eps} 
 	\caption{Diagrama de componentes de la configuración CollectionC}
\end{figure}

En la figura 5.1 se describe la configuración utilizando el lenguaje visual de descripción de componentes y sus relaciones, propuesto en el libro TinyOS Programming\cite{TinyOSProgramming}. La configuración consta de dos grandes módulos: El \textbf{módulo RouterP y el módulo ForwardeP}. El módulo RouterP se encarga de incorporar el nodo a la red, proveer al módulo ForwarderP del próximo salto, y tolerar fallas debido a la desaparición de nodos de la red. El módulo ForwarderP se encarga de: colocar en la cola de envío los mensajes que la aplicación necesita enviar (interfaz Send); recibir los mensajes de los nodos hijos; encolar los mensajes recibidos; y detectar la desaparición de nodos. \\

Para que el usuario pueda configurar los parámetros de funcionamiento del protocolo se provee el archivo Config.h, donde, mediante definiciones para el preprocesador C, el usuario puede configurar parámetros que se describirán en esta sección.

\subsection{Componente RouterP}
%Qué es?
El componente Router es el que implementa las secuencias de asociación y reconexión. El componente provee a la configuración la interfaz SplitControl y al módulo ForwarderP la interfaz RouterInfo.

%Interfaz SplitControl-Secuencia de Asociación Beacon Request
\subsubsection{Interfaz SplitControl}
La implementación comienza con la programación de la interfaz SplitControl. Esta interfaz permite a la capa de aplicación, iniciar el componente de ruteo utilizando el comando SplitControl.start(). Cuando se invoca este comando, este inicia el componente LPL con el intervalo definido como LPL\textunderscore INTERVAL en el archivo Config.h. A continuación, inicia la pila ActiveMessage y el timer BeaconRequestTimer con el intervalo BEACON\textunderscore REQUEST\textunderscore INTERVAL, configurable en Config.h. De esta forma se inicia la secuencia de asociación y durante este periodo se mantiene el estado del nodo en la red como NO\textunderscore NWK (sin red). \\

Durante el tiempo que transcurre entre cada BEACON\textunderscore REQUEST, el nodo almacena los BEACON\textunderscore RESPONSE, y cuando se gatilla nuevamente el timer, determina el mejor candidato para realizar la asociación. Si el nodo ha recibido mensajes BEACON\textunderscore RESPONSE y ha determinado un candidato para solicitar la asociación a la red, envía un JOIN\textunderscore REQUEST al candidato. Si no ha encontrado ningún candidato, vuelve a enviar un BEACON\textunderscore REQUEST.\\

Se implementan dos formas de determinar el candidato para requerir asociación: Por mayor RSSI, elige el nodo ''más cercano electromagnéticamente''; y por menor profundidad, se elige el nodo de menor profundidad en la red, pero que tenga un RSSI mayor a -87[dBm], que se ha medido como el mínimo para garantizar una tasa de recepción de mensajes correctos de 85\%  \cite{RSSIUnder}. La utilización de uno de estos esquema se deja configurable en el archivo Config.h, mediante las definiciones SELECT\_BEACON\_BY\_RSSI y SELECT\_BEACON\_BY\_DEPTH. \\

Cuando el nodo recibe un mensaje JOIN\textunderscore OK el nodo establece sus variables de red depth (profundidad) y parent (padre), con los valores obtenidos de este mensaje. Posteriormente cambia al estado IN\_NWK, activando el envío de ACKs con la interfaz CC2420Config y señalizando el evento SplitControl.startDone(SUCCESS) a la aplicación. La señalización de este evento permite que la aplicación esté en conocimiento del momento en que dispone de red para poder enviar mensajes de datos al Gateway.\\

Un punto importante en la implementación, es la incorporación de un sistema de ''Despliegue forzado de la red'', similar al desarrollado para la implementación de PEGASIS, para permitir el desarrollo de pruebas multihop en el laboratorio. El sistema utiliza la matriz ''hopsMatrix'', que implementada en un arreglo bidimensional que describe con un 0, 1 ó 10 la posibilidad de comunicación entre dos nodos. 

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.5]{imgs/hopsmatrix.eps} 
 	\caption{Ejemplo de matriz utilizada para el sistema de despliegue forzado }
\end{figure}

En la figura 5.2. se muestra una de las matrices utilizada para las pruebas. Cero se utiliza sólo para representar la relación entre un nodo con sí mismo; un 1 en una fila M y columna N, indica que el nodo M puede recibir mensajes del nodo N; mientras que un 10 en la fila M y columna N, indica que el nodo M no puede recibir mensajes del nodo N. Por ejemplo: el 1 en la posición (0,1) indica que el nodo 0 puede recibir mensajes del nodo 1; mientras que el 10 en la posición (0,2), indica que el nodo 0 no puede recibir mensajes del nodo 2. Cuando está activado el despliegue forzado, se utiliza la función ''bool isVisible(uint16\_t id)'' para revisar si un mensaje recibido se procesará o no. Para activar el despliegue forzado, basta con definir ''FORCED\_DEPLOYMENT'' en el archivo Config.h.

\subsection{Componente ForwarderP}
El componente ForwarderP es el encargado de implementar las secuencias de envío y reenvío multihop. Provee a la configuración las interfaces Init, Send, Receive y ForwarderInfo. ForwarderInfo es la interfaz desarrollada para proveer información desde el Forwarder a otros componentes.
%Interfaz Init?

\subsubsection{Interfaz Send}
La implementación del componente Forwarder comienza con la implementación de la interfaz Send. La interfaz Send proporciona el comando Send.getPayload, el comando Send.send, y el evento Send.sendDone.\\

El comando Send.getPayload se utiliza para proporcionar a la aplicación el espacio de memoria para que escriba el mensaje datos que desea enviar. Este comando recibe como entrada un puntero a una estructura ''message\textunderscore t''  y el tamaño del mensaje. Con estos datos, el comando se encarga de crear el espacio de memoria para el mensaje, del tamaño solicitado por la aplicación más el tamaño de la cabecera  ''MHData'', según lo definido en la sección 4.3.1. Finalmente, retorna un puntero a la dirección del payload del mensaje. Esta implementación, permite a la aplicación la utilización de mensajes de largo variable y no limitar a la aplicación a utilizar mensajes de un largo fijo.\\

El comando Send.send es el que permite a la aplicación colocar un mensaje en la cola de envío. Recibe como entrada un puntero a la estructura del mensaje ''message\textunderscore t'' y el largo. 

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.6]{imgs/DiagramaFlujoComandoSendSend.eps} 
 	\caption{Diagrama de flujo de la implementación del comando Send.send}
\end{figure}

Como muestra el diagrama de flujo en la figura 5.3, el comando Send.send comienza llenando la cabecera del mensaje, utilizando la interfaz RouterInfo para obtener el padre del nodo y la profundidad a la cuál se encuentra en la red. Además, escribe en la cabecera  el campo originaddr con el TOS\textunderscore NODE \textunderscore ID del nodo, y el contador de mensajes de datos en el campo seqnum. Posteriormente, se utiliza la interfaz MessagePool para obtener un espacio de memoria para el mensaje utilizando el comando MessagePool.get(), y si la ejecución del comando resulta exitosa, se copia el mensaje desde la aplicación a la MessagePool. A continuación, se encola el puntero al mensaje almacenado en la MessagePool en la cola FIFO SendQueue, y si resulta exitoso, se encola la tarea sendTask.\\

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.6]{imgs/DiagramaFlujoSendTask.eps} 
 	\caption{Diagrama de flujo de la implementación de la tarea SendTask}
\end{figure}

%Hablar de la sendTask
La tarea sendTask, es una tarea nesC que se encarga de sacar los mensajes de la cola y enviarlos por el aire. Cada vez que se encola un mensaje, se realiza un post de la tarea sendTask. Si la cola no está vacía, la tarea extrae la cabeza de la cola (el mensaje encolado más antiguo) e intenta enviarlo por el aire, utilizando la pila ActiveMessage. Si el envío se realiza con éxito, el sistema invoca al manejador del evento sendDone (ver figura 5.5), si se ha recibido un ACK del nodo destinatario, el manejador del evento elimina el mensaje más antiguo en la cola y si la cola aún no está vacía, vuelve a realizar un post de la sendTask. Si no se ha recibido un ACK, se vuelve a realizar un post de la sendTask, pero sin eliminar el mensaje más antiguo de la cola, forzando su reintento.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.6]{imgs/DiagramaFlujoMHSendDone.eps} 
 	\caption{Diagrama de flujo de la implementación del evento MHSend.sendDone}
\end{figure}

%Reenvío y enconlado de mensajes recibidos
\subsubsection{Interfaz MHReceive.receive}
El componente ForwarderP es el que implementa la interfaz MHReceive.receive, que es la que maneja el evento gatillado por la recepción de mensajes de datos multihop. 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{imgs/DiagramaFlujoReceiveBroadcast.eps}
	\caption{Diagrama de flujo de la implementación del evento MHReceive.receive}
\end{figure}

Como se muestra en la figura 5.6, cuando se recibe un mensaje de datos, primero se revisa el campo ''type'' en la cabecera para revisar si es un mensaje broadcast. Si lo es, se revisan los campos ''originaddr'' y ''bcast\_seqnum'' para revisar si es un mensaje repetido, si no lo es, se actualiza la cabecera y se señaliza el evento Broadcast.Receive entregando a la aplicación el mensaje, el payload y el largo. Luego de que se señaliza el Broadcast recibido, el mensaje se vuelve a encolar (sólo si el bcast\_radius es mayor que 0 después de ser decrementado). Si el mensaje no era de tipo broadcast, entonces se encola en la cola FIFO SendQueue y se realiza un post de la tarea sendTask.
	
\subsubsection{Interfaz Broadcast}
La interfaz Broadcast se ha implementado con el objetivo de proveer al sistema un medio de comunicación hacia los nodos, que permita por ejemplo: configurar la frecuencia con la que realizan las mediciones, o el sensor del cuál se desean obtener mediciones. También se permite que un nodo envíe un broadcast a los nodos de la red. \\

Los procesos realizados para enviar un mensaje de broadcast son los mismos que se describen en la figura 5.4, de la implementación del comando Send. Difieren en que al llenar la cabecera, el campo ''type'' indica que es un mensaje de broadcast, el ''bcast\_seqnum'' se llena con un valor válido (se incrementa con cada envío broadcast) y también se llena el campo ''bcast\_radius'', con el radio que ha indicado la aplicación. Los procesos de reenvío de los mensajes de broadcast se describieron en la sección anterior.

\section{Pruebas de verificación}
%Prueba de esta funcionalidad
Las pruebas de verificación de la funcionalidades implementadas, se realizan utilizando el sistema de despliegue forzado y la aplicación WSNSniffer. Esta última se modificó para que soportara el formato de los nuevos mensajes especificados en la sección 4.3.1.
 
\subsection{Pruebas al módulo RouterP}
En esta sección se describen las pruebas realizadas y los resultados para verificar las siguientes funcionalidades del módulo RouterP: Descubrimiento de red, Secuencia de Asociación, Asociación por RSSI, Asociación por Profundidad.

\subsubsection{Descubrimiento de red}
La primera prueba consiste en verificar que el mensaje beacon request se envíe periódicamente mientras el nodo no encuentre un nodo en la red con el cuál asociarse. Para esta prueba se utiliza la aplicación de prueba SampleApp, que se encuentra en el CD adjunto a este trabajo, que periódicamente realiza una medición con el sensor de luz y la envía hacia el Gateway utilizando el protocolo implementado. Para esta prueba el TMoteSky que corre SampleApp tiene un ID igual a 1 y un intervalo BEACON\textunderscore REQUEST\textunderscore INTERVAL igual a 1[s].

\begin{table}[H]
\centering
\caption{Extracto del reporte del sniffer para la prueba de descubrimiento de red}
 \includegraphics[scale=0.5]{imgs/ResultadosProcesadosBeaconLoop.eps}
\end{table}

En el cuadro 5.1 se muestra el resultado de la prueba registrado por el sistema Sniffer. La columna ''Timestamp'' muestra el tiempo en que la aplicación Sniffer recibió el mensaje. En promedio, el tiempo de recepción del mensajes es de 975[ms], lo cuál está un 2,5\% por debajo del valor configurado. La columna ''Src Addr'' muestra el TOS\textunderscore NODE\textunderscore ID del dispositivo origen del mensaje, este corresponde al valor 1, que fue el valor configurado para el dispositivo utilizado para esta prueba. La columna ''Dest Addr'' muestra el TOS\textunderscore NODE\textunderscore ID del destinatario del mensaje, en este caso, corresponde a la dirección de broadcast 65535 o 0xFFFF en notación hexadecimal. Ambos identificadores son obtenidos de la cabecera Active Message, para diferenciarlos de los identificadores que se incluyen en la cabecera de los mensajes implementados para la red. La columna ''AM Type'' muestra el identificador Active Message que se ha definido para este tipo de mensajes, que corresponde a 32 (0x21 en hexadecimal) para los mensajes de Topología.\\

Se puede apreciar que tal como se describe la secuencia de asociación en el capítulo 3, el nodo envía beacon request periódicamente , aproximadamente cada 1[s] y se mantiene así al no existir una red en el radio de alcance. 

\subsubsection{Secuencia de Asociación}
A continuación se realiza la misma prueba, pero agregando el nodo Gateway, que por si solo se encuentra en la red, y que debería responder los beacon request del nodo de prueba.

\begin{table}[H]
\centering
\caption{Resultado de prueba de la secuencia de asociación}
 \includegraphics[scale=0.6]{imgs/ResultadosProcesadosTestsJoinRequest.eps}
\end{table}

%Comentario del resultado de la prueba
En el cuadro 5.2 se muestra el resultado registrado por el sistema sniffer para la prueba de secuencia de asociación satisfactoria. En el cuadro se observa que el dispositivo con TOS\textunderscore NODE\textunderscore ID 1 envía un mensaje con subtype = 0x0, que corresponde al mensaje de topología BEACON\textunderscore REQUEST\textunderscore , a la dirección de broadcast. El dispositivo de TOS\textunderscore NODE\textunderscore ID 0 (nodo Gateway) responde con tres mensajes con subtype igual a 0x1, que corresponde al mensaje de topología BEACON\_RESPONSE. El largo de la ráfaga de mensajes de respuesta es configurable en definición del  BEACON\textunderscore RESPONSE\textunderscore BLAST\textunderscore SIZE en el archivo Config.h, esto permite al nodo 1 obtener varias muestras de RSSI y obtener un promedio de estos valores, que le permitirán decidir cuál nodo elegirá como candidato de padre en la red. En cada uno de los mensajes BEACON\_RESPONSE, el campo destaddr igual a 0x0 indica que el nodo 0 está respondiendo al nodo 1. El campo depth igual a 0 indica que la profundidad del nodo 0 en la red es 0. El campo joining igual a 0x1 indica que el nodo está incorporando nodos hijos a la red. El campo isCollector igual a 0x1 indica que el nodo 0 es el recolector (y Gateway). A continuación, el nodo 1 responde al BEACON con un mensaje de subtype igual a 0x2, que corresponde al mensaje de topología JOIN\textunderscore REQUEST. El campo destaddr igual a 0x0 indica que el mensaje está dirigido al nodo 0, ya que el nodo eligió al nodo 0 como candidato de padre en la red. El campo  joining igual a 0x1, esto indicaría que el nodo 1 está aceptando asociaciones, pero ya que no está en la red, no responderá a mensajes BEACON\textunderscore REQUEST\textunderscore , ni el nodo 0 utilizará esa información en el proceso de asociación. El campo isCollector es igual a 0x0, indicando que el nodo 1 no es recolector. El campo redundancy es un campo que se utilizó de manera experimental y se mantuvo en la estructura del mensaje para futuros desarrollos.\\

\subsubsection{Verificación de asociación por mayor RSSI}
Para verificar la funcionalidad de asociación mediante la utilización del mayor RSSI, se realiza el siguiente experimento. Primero se despliegan espacialmente 3 nodos: nodo Gateway (0), nodo 1 y nodo 2. como se muestra en la figura 5.7

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.6]{imgs/TopologiaDesplieguePruebaAsociacionRssi.eps} 
 	\caption{Topología forzada para prueba de limitación de hijos}
\end{figure}

Como muestra la figura 5.7, los nodos se despliegan linealmente, donde el nodo 1 se encuentra a 3 [m] del nodo 0, mientras que el nodo 2 a 3.5[m] del nodo 0 y 0.5 del nodo 1. Con esta disposición, el nodo 2 debería medir diferencias entre los indicadores RSSI medidos para los mensajes del nodo 1 y el nodo 0.  El objetivo, es que el nodo 2 reciba beacons de ambos nodos, pero que elija el nodo que envió beacons con un RSSI promedio más alto. 

\begin{center}
\begin{table}[H]
\caption{Resultado de prueba de asociación por mayor RSSI}
 \includegraphics[scale=0.6]{imgs/ResultadosProcesadosTestsAsociacionRSSI.eps}
\end{table}
\end{center}

En el cuadro 5.3 se muestra la secuencia de mensajes capturada por el sniffer para la prueba. La secuencia capturada es la secuencia de asociación del nodo 2. Se observa que el nodo 2 en el tiempo 0:46:56:126 inicia la asociación enviando un BEACON\textunderscore REQUEST a la dirección de broadcast. Los nodos 0 y 1 responden con los respectivos mensajes BEACON\textunderscore RESPONSE. Luego, el nodo 2 elige unirse al nodo 1 y en el tiempo 00:46:57:083 envía un mensaje de JOIN\textunderscore REQUEST. Finalmente, recibe un JOIN\textunderscore OK para confirmar la asociación. El resultado de esta secuencia es la asociación del nodo 2 al nodo 1, que es lo esperado si es que el nodo 2 midió un RSSI promedio más alto de los mensajes BEACON\textunderscore RESPONSE del nodo 1 que del nodo 2. Sin embargo, con el sniffer no se puede confirmar ese comportamiento. Por esta razón, se implementó que el nodo 2 enviara por comunicación serial la tabla ' beaconList ', que es el arreglo bidimensional que utiliza para almacenar los datos de los BEACON\textunderscore RESPONSE recibidos.\\

\begin{center}
\begin{table}[H]
\caption{Output recibido por puerto serial del nodo 2}
 \includegraphics[scale=0.6]{imgs/OutputAsociacionRssi.eps}
\end{table}
\end{center}

En el cuadro 5.4 se muestran las 15 entradas, de las cuales sólo las primeras seis son válidas (campo valid igual a 65534 es válido y 65535 es inválido). Estas entradas válidas corresponden a seis mensajes BEACON\textunderscore RESPONSE que recibió el nodo 2. Las entradas 0, 1 y 2 corresponden a mensajes del nodo 0 y el promedio entero de sus RSSI es -32 [dBm]. Las entradas 3, 4 y 5 corresponden a mensajes del nodo 1 y el promedio entero de sus RSSI es 8 [dBm]. De esta manera, se verifica que el nodo 2 eligió como candidato para la asociación al nodo del que recibió los mensajes BEACON\textunderscore RESPONSE con mayor RSSI.\\

\subsubsection{Verificación de asociación por menor profundidad}
%Probar formas de asociación, DEPTH
Para verificar la funcionalidad de la asociación por menor profundidad, se utiliza el mismo despliegue no forzado utilizado y mostrado en la figura 5.7. Además, se vuelve a utilizar la herramienta ''printf'' para enviar por comunicación serial al computador la tabla 'beaconList'.

\begin{center}
\begin{table}[H]
\caption{Resultado de prueba de asociación por menor profundidad}
 \includegraphics[scale=0.6]{imgs/ResultadosProcesadosTestsAsociacionPorDepth.eps}
\end{table}
\end{center}

La secuencia de asociación comienza en el tiempo 0:38:56:207, cuando el nodo 2 envía un mensaje BEACON\textunderscore REQUEST a la dirección de broadcast. A continuación, los nodos 0 y 1 responden con los mensajes BEACON\textunderscore RESPONSE correspondientes. Luego, en el tiempo 0:38:57:164 el nodo 2 solicita una asociación al nodo 0, y este confirma la asociación en el tiempo 0:38:57:200. La secuencia resultante es la esperada de acuerdo al criterio de asociación por menor profundidad, debido a que el nodo 2 decide solicitar la asociación al nodo 0 en vez del nodo 1, ya que el nodo 0 tiene la menor profundidad. Sin embargo, para asegurar que el nodo no está siguiendo el criterio de RSSI, se revisa la tabla de beacons enviada por comunicación serial por el nodo al computador.

\begin{center}
\begin{table}[H]
\caption{Output recibido por puerto serial del nodo 2}
 \includegraphics[scale=0.6]{imgs/OutputAsociacionProfundidad.eps}
\end{table}
\end{center}

Como se observa en el cuadro 5.6, el nodo 1 tiene RSSI mucho mayores que el nodo 0, por lo que claramente el nodo 2 no utilizó el criterio de mayor RSSI para elegir el nodo al cual solicitar la asociación.

\subsection{Pruebas al módulo ForwarderP}
En esta sección se describen las pruebas realizadas y los resultados para verificar las siguientes funcionalidades del módulo ForwarderP: Verificación de reenvío de mensajes y Verificación de broadcast de red.

\subsubsection{Verificación de reenvío de mensajes}
Para verificar que el reenvío de los mensajes va de padre en padre hasta el Gateway, se revisa el reporte del sniffer para un despliegue forzado de la red. La primera prueba, se realiza con el despliegue descrito en la figura 5.8.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.6]{imgs/DesplieguePruebaToleranciaFallas.eps} 
 	\caption{Despliegue para primera prueba de verificación de reenvío}
\end{figure}
 
En el cuadro 5.7 se muestra un Extracto del reporte del sniffer entregado para esta prueba. Para verificar que los mensajes viajan de padre en padre hasta el Gateway (nodo 0), basta con observar como viaja, por ejemplo, el mensaje generado por el nodo 4 en el timestamp 21:55:54:790. Se observa en la columna SrcAddr que ese mensaje fue enviado en ese salto por el nodo 4, y en la columna Data, que la dirección de origen del mensaje de datos es el nodo 2. Por lo tanto, ese mensaje fue generado inicialmente por el nodo 4. A continuación, se observa que el mensaje reenviado por el nodo 3 al 1, es exactamente el mismo que envió anteriormente el nodo 4. Finalmente, en el timestamp 21:55:55:045 el mismo mensaje es reenviado a su destino final, el Gateway (nodo 0). Si se realiza el mismo ejercicio con el resto de los mensajes, se confirma que todos los mensajes generados por los 5 nodos de la red, fueron reenviados de padre en padre hasta el Gateway. 
 
\begin{center}
\begin{table}[H]
\caption{Resultado de la primera prueba de reenvío}
 \includegraphics[scale=0.6]{imgs/ResultadosProcesadosTestReenvioTop2.eps}
\end{table}
\end{center}
%Probar broadcast
\subsubsection{Verificación de broadcast de red}
Para verificar la funcionalidad de la implementación del broadcast de red, se realiza el siguiente experimento:

\begin{itemize}
 \item Se implementa utilizando la configuración de despliegue forzada, una red lineal, con 4 nodos, donde el nodo 1 es el más cercano al Gateway y el 4 es el más lejano.

 \item Se implementa una aplicación de prueba que envía un mensaje de broadcast, con radio dinámico. Cada vez que se presiona el botón de usuario, con esto gatilla el envío del mensaje de broadcast, y el incremento del radio para el próximo mensaje.

 \item Una vez formada la red, se presiona el botón del nodo 4 varias veces y se captura con el Sniffer la secuencia de mensajes generada.
\end{itemize}

En el cuadro 5.8, se observa el resultado capturado por el sniffer cuando el nodo 4 envía el broadcast con radio 2. El mensaje es enviado por el nodo 4 en el timestamp 19:54:45:245, y a continuación es reenviado por el resto de los nodos, y con cada salto, se decrementa el campo ''bcast\_radius''.

\begin{center}
\begin{table}[H]
\caption{Secuencia capturada del broadcast con radio 2}
 \includegraphics[scale=0.6]{imgs/ResultadosProcesadosTestsBroadcastRadio2.eps}
\end{table}
\end{center}
%En el cuadro 5.9, se observa cuando el nodo envía el broadcast con radio 3.
%\begin{center}
%\begin{table}[H]
 %\includegraphics[scale=0.6]{imgs/ResultadosProcesadosTestsBroadcastRadio3.eps}
%\caption{Secuencia capturada del broadcast con radio 3}
%\end{table}
%\end{center}

%El mensaje es enviado por el nodo 4 en el timestamp 19:56:02:723, y a continuación es reenviado por el resto de los nodos, y con cada salto, se decrementa el campo ''bcast\_radius''.
\subsection{Prueba de verificación de tolerancia a fallas}
Para verificar la tolerancia a falla para la desaparición de un nodo se utiliza el despliegue forzado que se muestra en la figura 5.9.

\begin{figure}[H]
	\centering
 	\includegraphics[scale=0.6]{imgs/DesplieguePruebaToleranciaFallas.eps} 
 	\caption{Despliegue la prueba de desaparición de un nodo}
\end{figure}

Con la red funcionando, se remueven las baterías del nodo 3 y se registra el comportamiento con el sniffer.\\

En el cuadro 5.9 se muestra el resultado obtenido. Como se ha configurado en el archivo Config.h, el nodo 4 intenta enviar tres veces el mensaje de datos con seqnum igual a 0x5 al nodo 3. Luego de los reintentos, en el timestamp 22:29:05:902 el nodo envía un BEACON\_REQUEST para solicitar una nueva asociación. El nodo 2, responde satisfactoriamente y asocia al nodo 4 nuevamente. El nodo 5 realiza la misma operación, el registro completo de la prueba se encuentra en el CD adjunto a este trabajo.\\

\begin{table}[H]
\centering
\caption{Registro de la detección del nodo perdido y la reconexión del nodo 4}
 \includegraphics[scale=0.6]{imgs/ResultadosProcesadosTestsToleranciaFallaMuerte.eps}
\end{table}

\subsection{Prueba de verificación de red multihop}
%Prueba Depto elo.
Para validar el funcionamiento multihop en un escenario ''medianamente real'' se desplegó la red en las instalaciones del departamento de electrónica (Edificio B, 3er piso), por un periodo tiempo de 30 minutos. En el archivo Config.h, se deshabilita la opción de despliegue forzado y se utilizó el sistema de asociaciones por RSSI  En la figura 5.10 se muestra la disposición en el plano de los nodos.

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.5]{imgs/RedDeptoElo.eps}
 \caption{Despliegue de los nodos en el Departamento de Electrónica. Tercer piso, edificio B, Casa Central de la UTFSM}
\end{figure}

Los resultados fueron bastante satisfactorios, la formación de la red funcionó sin problemas, estableciendo la siguiente topología:

\begin{table}[H]
\centering
\caption{Asociaciones resultantes en el despliegue en el Departamento de Electrónica}
 \includegraphics[scale=0.6]{imgs/ResultadosProcesadosTestsTopologiaDeptoElo.eps}
\end{table}
 
 Además, analizando el reporte se verifica que se rutearon al Gateway la totalidad de los mensajes generados.
 
\section{Evaluación Energética}
%Utilizando el mismo sistema de medición de corriente consumida presentado en la sección XX, se realiza una evaluación del protocolo en distintos escenarios. Primero, se realiza un experimento para medir el comportamiento energético en función del intervalo LPL y el intervalo de generación de mensajes. A continuación se realiza otro experimento para medir el comportamiento energético en función de la topología de la red.

%\subsection{En función del intervalo de generación de mensajes}

Utilizando el mismo sistema de medición de corriente consumida presentado en la sección 3.4.1, se realiza una evaluación del protocolo, forzando el despliegue para que resulte en una topología de árbol con dos niveles, donde en el primer nivel se encuentra el nodo 1 (hijo del Gateway) y 4 nodos restantes en el segundo nivel (hijos del nodo 1). En los nodos se utilizó la aplicación SampleApp (incluida en el CD adjunto a este trabajo), que periódicamente toma una medición con el sensor de luz y la envía hacia el Gateway, utilizando el protocolo de red implementado. Se utilizó un intervalo LPL fijo de 500 milisegundos, y se midió la corriente media utilizada por el nodo 1 (el nodo que maneja más tráfico) para distintos intervalos de generación de mensajes.

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.4]{imgs/MiProtoTopEstrellaFrecuenciamensajesLpl500.eps}
 \caption{Consumo en nodo con más tráfico en un árbol de dos niveles}
\end{figure}

En la figura 5.11, se observa que la corriente media utilizada por el TMoteSky para los intervalos de 200[ms] y 400[ms] alcanza los niveles más bajos, esto se debe a que esos intervalos son menores al intervalo LPL, y en estos casos la tasa de recepción de mensajes correctos fue nula. Lo anterior sólo se realizó con fines experimentales, para determinar cuál sería el comportamiento para intervalos de envío de mensajes menores al intervalo LPL. Según los resultados obtenidos, el  consumo máximo corresponde a 7,44[mA] con un intervalo de generación de mensajes de 600 [ms]. El consumo mínimo fue para el intervalo de 2000[ms] y equivale a 3,19[mA]. Con este mínimo de consumo, se estima que utilizando baterías que proporciones una carga de 2400[mAh], la autonomía del nodo alcanza los 30 días, cumpliendo con el mínimo de lo propuesto en los objetivos (ver Sección 1.3).\\

Como se muestra en la figura 5.11, posteriormente al intervalo de 600 [ms], el consumo decrece progresivamente. En consecuencia, se realiza la misma evaluación para intervalos de generación de mensajes más largos, como se muestra en la figura 5.12.

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.3]{imgs/GraficoConsumoLpl500IntervaloLargo.eps}
 \caption{Consumo en nodo con más tráfico en un árbol de dos niveles, para intervalos de generación de mensajes más largos}
\end{figure}

Como muestra la figura 12, con intervalos más largos el consumo es aún menor. Con 30000 [ms] se obtiene una corriente media de 0,95 [mA]. Con este consumo, se estima que utilizando baterías que proporcionen una carga de 2400[mAh], la autonomía del nodo alcanza los 105 días, lo que representa más de 3 meses.\\

Para contrastar los resultados con otro protocolo, se implementó una aplicación que utiliza el protocolo CTP para recolectar mediciones. Sin embargo, cuando se activa el componente LPL en esta aplicación, el protocolo no logra formar una red. Este comportamiento ha sido documentado por  el grupo de trabajo de red para TinyOS2.x\cite{Net2WG} y en su programa de trabajo se incluye agregar la compatibilidad de CTP con LPL. En febrero de 2010 se revisó por última vez el código fuente de CTP y aún no se ha incorporado la compatibilidad, según el sitio del grupo de trabajo, todavía está en periodo de pruebas.

%\subsubsection{En función de la topologia}
%Se implementa una red con un árbol de dos niveles, igual a la implementada en la sección XX, pero los nodos del segundo nivel se ingresan de a uno, para medir el consumo de corriente el nodo padre en función del número de hijos.
 
 
 
%Para medir la distribución del consumo de corriente en función de la profundidad, se despliega una red con topología lineal, es decir, un árbol de cinco niveles, con un nodo por nivel.

